// Generated from Expressions.g4 by ANTLR 4.7.

package parser // Expressions
// See base listener file for example implementations

//import "github.com/antlr/antlr4/runtime/Go/antlr"



// import "generate package"

//type ExpressionsVisitor struct {
//    *antlr.BaseParseTreeVisitor
//}

//var _ parser.StartContextVisitor = &ExpressionsVisitor{}
//var _ parser.CodelineContextVisitor = &ExpressionsVisitor{}
//var _ parser.AddSubExprContextVisitor = &ExpressionsVisitor{}
//var _ parser.ParenExprContextVisitor = &ExpressionsVisitor{}
//var _ parser.LiteralExprContextVisitor = &ExpressionsVisitor{}
//var _ parser.UnaryExprContextVisitor = &ExpressionsVisitor{}
//var _ parser.UnaryContextVisitor = &ExpressionsVisitor{}
//var _ parser.IntLiteralContextVisitor = &ExpressionsVisitor{}


//func (v *ExpressionsVisitor) VisitNext(node antlr.Tree, current interface{}) bool {
//    return true
//}
//func (v *ExpressionsVisitor) VisitRest(node antlr.RuleNode, current interface{}) bool {
//    return true
//}
//func (v *ExpressionsVisitor) AggregateResult(aggregate, nextResult interface{}) (result interface{}) {
//    return nextResult
//}
//func (v *ExpressionsVisitor) VisitTerminal(node antlr.TerminalNode) {
//}
//func (v *ExpressionsVisitor) VisitErrorNode(node antlr.ErrorNode) {
//}

//func (v *ExpressionsVisitor) VisitStart(ctx parser.IStartContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

//func (v *ExpressionsVisitor) VisitCodeline(ctx parser.ICodelineContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

//func (v *ExpressionsVisitor) VisitAddSubExpr(ctx parser.IAddSubExprContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

//func (v *ExpressionsVisitor) VisitParenExpr(ctx parser.IParenExprContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

//func (v *ExpressionsVisitor) VisitLiteralExpr(ctx parser.ILiteralExprContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

//func (v *ExpressionsVisitor) VisitUnaryExpr(ctx parser.IUnaryExprContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

//func (v *ExpressionsVisitor) VisitUnary(ctx parser.IUnaryContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

//func (v *ExpressionsVisitor) VisitIntLiteral(ctx parser.IIntLiteralContext, delegate antlr.ParseTreeVisitor, args ...interface{}) (result interface{}){
//  TODO list rules here
//  Visit rules manually
//  eg a : b c* | d;
//  if ctx.GetB() != nil {
//    result1 = ctx.GetB(ctx, delegate, args)
//    for _, c := range ctx.GetC() {
//      resultS = c.GetC(ctx, delegate, args)
//    }
//  } else { ... }
//  OR visit all children rules
//  // before children
//  v.VisitChildren(ctx, delegate)
//  // afer children
//
//  return result
//}

